---
output:
  github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# cnefetools: Tools for working with Brazilian CNEFE address data <img src="man/figures/logo.png" alt="logo" align="right" width="190"/>

[![R-CMD-check](https://github.com/pedreirajr/cnefetools/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/pedreirajr/cnefetools/actions/workflows/R-CMD-check.yaml) [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE.md) [![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)

**{cnefetools}** provides helper functions to work with the 2022 Brazilian National Address File for Statistical Purposes (*Cadastro Nacional de Endereços para Fins Estatísticos*, CNEFE), an address-level dataset released by the Brazilian Institute of Geography and Statistics (*Instituto Brasileiro de Geografia e Estatística*, IBGE).

## Installation

Install the stable version from CRAN:

```{r eval=FALSE, message=FALSE}
install.packages("cnefetools")
```

To install the development version from GitHub:

```{r eval=FALSE, message=FALSE}
# install.packages("pak")
pak::pak("pedreirajr/cnefetools")

# or
# install.packages("remotes")
remotes::install_github("pedreirajr/cnefetools")

# or
# install.packages("devtools")
devtools::install_github("pedreirajr/cnefetools")
```

## Overview

| Function | Description |
|------------------------------------|------------------------------------|
| `read_cnefe()` | Downloads and reads CNEFE data for a municipality; returns an Arrow table or `sf` object |
| `cnefe_counts()` | Aggregates address counts to H3 hexagons or user-provided polygons |
| `compute_lumi()` | Computes land-use mix indices on H3 hexagons or user-provided polygons |
| `tracts_to_h3()` | Dasymetric interpolation of census tract variables to an H3 grid via CNEFE dwelling points |
| `tracts_to_polygon()` | Dasymetric interpolation of census tract variables to user-provided polygons via CNEFE dwelling points |
| `cnefe_doc()` | Opens the official CNEFE methodological note (PDF) |
| `cnefe_dictionary()` | Opens the official CNEFE variable dictionary (Excel) |

## Reading CNEFE data

`read_cnefe()` downloads and reads the CNEFE CSV for a municipality, returning an Arrow table by default:

```{r, message=FALSE, warning=FALSE}
library(cnefetools)
library(dplyr)

# Read CNEFE data for Salvador as an Arrow table
tab_ssa <- read_cnefe(2927408, cache = TRUE)

tab_ssa |>
  collect() |> # materialize the arrow table in R
  dplyr::tibble() |>
  head()
```

Setting `output = "sf"` returns an `sf` object instead. The example below reads data for Salvador, filters religious facilities (`COD_ESPECIE == 8`), and plots them:

```{r, message=FALSE, warning=FALSE}
library(sf)
library(ggplot2)

tab_ssa_sf <- read_cnefe(code_muni = 2927408, output = "sf", cache = TRUE)

temples_ssa <- tab_ssa_sf |>
  dplyr::filter(COD_ESPECIE == 8)

ggplot() +
  geom_sf(data = temples_ssa, size = 0.3, alpha = 0.6) +
  coord_sf() +
  theme_minimal()
```

**Warning:** For large municipalities, CNEFE may contain more than 1 million address points. Plotting all coordinates at once can be slow and memory-intensive, so consider filtering or sampling before creating maps.

## Caching behavior

By default, `cache = TRUE` stores the downloaded ZIP file in a user-level cache directory specific to this package. If you prefer to avoid persistent caching, set:

```{r, eval=FALSE}
tab_ssa <- read_cnefe(code_muni = 2927408, cache = FALSE)
```

In this case, the ZIP file is stored in a temporary location and removed after reading.

## Accessing official CNEFE documentation

**{cnefetools}** includes local copies of the official methodological note and the variable dictionary for the 2022 CNEFE released by IBGE.

```{r, eval=FALSE}
# Open the official methodological note (PDF)
cnefe_doc(year = 2022)

# Open the official variable dictionary (.xls spreadsheet)
cnefe_dictionary(year = 2022)
```

## Counting addresses with `cnefe_counts()`

`cnefe_counts()` aggregates CNEFE address points into spatial units and returns an `sf` object with counts by address category (`addr_type1` to `addr_type8`). Below is an example using H3 hexagons for São Paulo at resolution 9:

```{r, message=FALSE, warning=FALSE}
library(cnefetools)
library(sf)
library(ggplot2)

hex_sp <- cnefe_counts(code_muni = 3550308, h3_resolution = 9, verbose = TRUE)

ggplot(hex_sp) +
  geom_sf(aes(fill = addr_type1), color = NA) +
  scale_fill_viridis_c(option = "magma", trans = "sqrt") +
  coord_sf() +
  labs(
    fill = "Count",
    title = "Private households (addr_type1)",
    subtitle = "São Paulo (IBGE 3550308), H3 resolution 9"
  ) +
  theme_minimal()
```

`cnefe_counts()` also supports `polygon_type = "user"` to aggregate counts to custom polygons instead of H3 hexagons. See `vignette("cnefe_counts")` for details.

## Land-use mix indices with `compute_lumi()`

`compute_lumi()` computes land-use mix indicators on spatial units for any municipality covered by the 2022 CNEFE dataset ([Pedreira Junior et al., 2025](https://engrxiv.org/preprint/view/5975/version/7846)). Available indicators include the Entropy Index (`ei`), HHI (`hhi`), Balance Index (`bal`), the Index of Concentration at Extrems (`ice`), adapted HHI (`hhi_adp`), and the Bidirectional Global-centered Balance Index (`bgbi`).

Below is an example for Fortaleza at H3 resolution 8:

```{r, message=FALSE, warning=FALSE}
library(cnefetools)
library(sf)
library(ggplot2)

lumi_ftl <- compute_lumi(code_muni = 2304400, h3_resolution = 8, verbose = TRUE)

ggplot(lumi_ftl) +
  geom_sf(aes(fill = bgbi), color = NA) +
  scale_fill_gradient2(
    low = "red",
    mid = "white",
    high = "blue",
    midpoint = 0,
    limits = c(-1, 1)
  ) +
  coord_sf() +
  labs(
    fill = "BGBI",
    title = "Bidirectional Global-centered Balance Index (BGBI)",
    subtitle = "Fortaleza (IBGE 2304400), H3 resolution 8"
  ) +
  theme_minimal()
```

`compute_lumi()` also supports `polygon_type = "user"` to compute indices on custom polygons. See `vignette("compute_lumi")` for details.

## Dasymetric interpolation with `tracts_to_h3()`

`tracts_to_h3()` performs a dasymetric interpolation, considering two stages: first, census tract totals are allocated to individual CNEFE dwelling points inside each tract; then, the allocated values are aggregated to an H3 grid at the chosen resolution. This leverages the fine-grained spatial distribution of addresses in CNEFE to produce more realistic sub-tract estimates than simple areal weighting.

```{r, message=FALSE, warning=FALSE}
library(cnefetools)
library(ggplot2)

rec_hex <- tracts_to_h3(
  code_muni = 2611606,
  h3_resolution = 9,
  vars = c("pop_ph", "avg_inc_resp"),
  cache = TRUE,
  verbose = TRUE
)
```

```{r, message=FALSE, warning=FALSE}
ggplot(rec_hex) +
  geom_sf(aes(fill = pop_ph), color = NA) +
  scale_fill_viridis_c() +
  coord_sf() +
  labs(
    title = "Dasymetric interpolation to H3 using CNEFE (Recife)",
    subtitle = "Private-household population (pop_ph), H3 resolution 9",
    fill = "Population"
  ) +
  theme_minimal()
```

```{r, message=FALSE, warning=FALSE}
ggplot(rec_hex) +
  geom_sf(aes(fill = avg_inc_resp), color = NA) +
  scale_fill_viridis_c() +
  coord_sf() +
  labs(
    title = "Dasymetric interpolation to H3 using CNEFE (Recife)",
    subtitle = "Average income of the responsible person (avg_inc_resp), H3 resolution 9",
    fill = "Income"
  ) +
  theme_minimal()
```

The full list of available variables is documented in the `tracts_variables_ref` dataset (see `?tracts_variables_ref`). For allocation rules and diagnostic details, see `vignette("tracts_to")`.

## Dasymetric interpolation with `tracts_to_polygon()`

`tracts_to_polygon()` follows the same two-stage workflow as `tracts_to_h3()`, but aggregates the allocated values to user-provided polygons (e.g. neighborhoods, administrative divisions, or custom areas) instead of an H3 grid. Let's generate the neighborhoods of Recife with the `read_neighborhood()` function from the `geobr` package and interpolate the average income of household heads per neighborhood:

```{r, warning = F, message = F}
library(geobr)
# Example: interpolate population to neighborhood polygons
rec_nei <- read_neighborhood(year = 2022, simplified = F, showProgress = F) |> 
  filter(name_muni == 'Recife')

rec_poly <- tracts_to_polygon(
  code_muni = 2611606,
  polygon = rec_nei,
  vars = c("pop_ph", "avg_inc_resp"),
  verbose = F
)

ggplot(rec_poly) +
  geom_sf(aes(fill = avg_inc_resp), color = NA) +
  scale_fill_viridis_c() +
  coord_sf() +
  labs(
    title = "Dasymetric interpolation to neighborhoods using CNEFE (Recife)",
    subtitle = "Average income of the responsible person (avg_inc_resp)",
    fill = "Income"
  ) +
  theme_minimal()
```

See `vignette("tracts_to")` for details.

## Citation

If you use **{cnefetools}** in your work, please cite the associated preprint:

> Pedreira Jr., J. U.; Louro, T. V.; Assis, L. B. M.; Brito, P. L. *Measuring land use mix with address-level census data* (2025). engrXiv. <https://engrxiv.org/preprint/view/5975>
